{"version":3,"sources":["webpack://ReactContexify/webpack/universalModuleDefinition","webpack://ReactContexify/webpack/bootstrap","webpack://ReactContexify/./src/expression.ts","webpack://ReactContexify/./src/strength.ts","webpack://ReactContexify/./src/constraint.ts","webpack://ReactContexify/./src/maptype.ts","webpack://ReactContexify/./src/variable.ts","webpack://ReactContexify/./src/index.ts","webpack://ReactContexify/./src/solver.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","maptype_1","variable_1","Expression","parsed","parseArgs","arguments","this","_terms","terms","_constant","constant","result","size","pair","itemAt","first","second","plus","minus","multiply","coefficient","divide","isConstant","toString","array","map","join","args","createMap","length","item","Variable","setDefault","j","k","terms2","termPair","Array","Error","value2","Strength","a","b","w","Math","max","min","clip","required","strong","medium","weak","expression_1","strength_1","Operator","Constraint","expression","operator","rhs","strength","_id","CnId","_operator","_strength","undefined","_expression","id","op","IndexedMap","index","empty","contains","find","Pair","push","insert","erase","last","pop","copy","_value","_context","VarId","_name","setName","context","setContext","setValue","toJSON","__export","SymbolType","constraint_1","Solver","_cnMap","_rowMap","_varMap","_editMap","_infeasibleRows","_objective","Row","_artificial","_idTick","createConstraint","lhs","cn","addConstraint","constraint","data","_createRow","row","tag","subject","_chooseSubject","type","Invalid","allDummies","nearZero","marker","_addWithArtificialVariable","solveFor","_substitute","_optimize","removeConstraint","cnPair","_removeConstraintEffects","rowPair","leaving","_getMarkerLeavingSymbol","solveForEx","hasConstraint","addEditVariable","variable","expr","Eq","info","removeEditVariable","editPair","hasEditVariable","suggestValue","rows","delta","add","_dualOptimize","other","rowPair_1","coeff","coefficientFor","External","updateVariables","vars","_getVarSymbol","_this","_makeSymbol","symbol","basicPair","insertRow","insertSymbol","objective","INVALID_SYMBOL","Le","Ge","slack","Slack","error","errplus","errminus","dummy","Dummy","reverseSign","cells","art","success","basicRow","entering","_anyPivotableSymbol","removeSymbol","substitute","_getEnteringSymbol","_getLeavingSymbol","infeasible","_getDualEnteringSymbol","ratio","Number","MAX_VALUE","found","temp","temp_ratio","dmax","r1","r2","invalid","third","_removeMarkerEffects","_type","_cellMap","theCopy"],"mappings":"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","file":"ReactContexify.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactContexify\"] = factory();\n\telse\n\t\troot[\"ReactContexify\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n","/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\n\nimport { createMap, IMap } from './maptype';\nimport { Variable } from './variable';\n\n/**\n * An expression of variable terms and a constant.\n *\n * The constructor accepts an arbitrary number of parameters,\n * each of which must be one of the following types:\n *  - number\n *  - Variable\n *  - Expression\n *  - 2-tuple of [number, Variable|Expression]\n *\n * The parameters are summed. The tuples are multiplied.\n *\n * @class\n * @param {...(number|Variable|Expression|Array)} args\n */\nexport class Expression {\n  constructor(...args: any[]);\n  constructor() {\n    let parsed = parseArgs(arguments);\n    this._terms = parsed.terms;\n    this._constant = parsed.constant;\n  }\n\n  /**\n   * Returns the mapping of terms in the expression.\n   *\n   * This *must* be treated as const.\n   * @private\n   */\n  public terms(): IMap<Variable, number> {\n    return this._terms;\n  }\n\n  /**\n   * Returns the constant of the expression.\n   * @private\n   */\n  public constant(): number {\n    return this._constant;\n  }\n\n  /**\n   * Returns the computed value of the expression.\n   *\n   * @private\n   * @return {Number} computed value of the expression\n   */\n  public value(): number {\n    let result = this._constant;\n    for (let i = 0, n = this._terms.size(); i < n; i++) {\n      let pair = this._terms.itemAt(i);\n      result += pair.first.value() * pair.second;\n    }\n    return result;\n  }\n\n  /**\n   * Creates a new Expression by adding a number, variable or expression\n   * to the expression.\n   *\n   * @param {Number|Variable|Expression} value Value to add.\n   * @return {Expression} expression\n   */\n  public plus(value: number | Variable | Expression): Expression {\n    return new Expression(this, value);\n  }\n\n  /**\n   * Creates a new Expression by substracting a number, variable or expression\n   * from the expression.\n   *\n   * @param {Number|Variable|Expression} value Value to substract.\n   * @return {Expression} expression\n   */\n  public minus(value: number | Variable | Expression): Expression {\n    return new Expression(\n      this,\n      typeof value === 'number' ? -value : [-1, value]\n    );\n  }\n\n  /**\n   * Creates a new Expression by multiplying with a fixed number.\n   *\n   * @param {Number} coefficient Coefficient to multiply with.\n   * @return {Expression} expression\n   */\n  public multiply(coefficient: number): Expression {\n    return new Expression([coefficient, this]);\n  }\n\n  /**\n   * Creates a new Expression by dividing with a fixed number.\n   *\n   * @param {Number} coefficient Coefficient to divide by.\n   * @return {Expression} expression\n   */\n  public divide(coefficient: number): Expression {\n    return new Expression([1 / coefficient, this]);\n  }\n\n  public isConstant(): boolean {\n    return this._terms.size() == 0;\n  }\n\n  public toString(): string {\n    let result = this._terms.array\n      .map(function(pair) {\n        return pair.second + '*' + pair.first.toString();\n      })\n      .join(' + ');\n\n    if (!this.isConstant() && this._constant !== 0) {\n      result += ' + ';\n    }\n\n    result += this._constant;\n\n    return result;\n  }\n\n  private _terms: IMap<Variable, number>;\n  private _constant: number;\n}\n\n/**\n * An internal interface for the argument parse results.\n */\ninterface IParseResult {\n  terms: IMap<Variable, number>;\n  constant: number;\n}\n\n/**\n * An internal argument parsing function.\n * @private\n */\nfunction parseArgs(args: IArguments): IParseResult {\n  let constant = 0.0;\n  let factory = () => 0.0;\n  let terms = createMap<Variable, number>();\n  for (let i = 0, n = args.length; i < n; ++i) {\n    let item = args[i];\n    if (typeof item === 'number') {\n      constant += item;\n    } else if (item instanceof Variable) {\n      terms.setDefault(item, factory).second += 1.0;\n    } else if (item instanceof Expression) {\n      constant += item.constant();\n      let terms2 = item.terms();\n      for (let j = 0, k = terms2.size(); j < k; j++) {\n        let termPair = terms2.itemAt(j);\n        terms.setDefault(termPair.first, factory).second += termPair.second;\n      }\n    } else if (item instanceof Array) {\n      if (item.length !== 2) {\n        throw new Error('array must have length 2');\n      }\n      let value: number = item[0];\n      let value2 = item[1];\n      if (typeof value !== 'number') {\n        throw new Error('array item 0 must be a number');\n      }\n      if (value2 instanceof Variable) {\n        terms.setDefault(value2, factory).second += value;\n      } else if (value2 instanceof Expression) {\n        constant += value2.constant() * value;\n        let terms2 = value2.terms();\n        for (let j = 0, k = terms2.size(); j < k; j++) {\n          let termPair = terms2.itemAt(j);\n          terms.setDefault(termPair.first, factory).second +=\n            termPair.second * value;\n        }\n      } else {\n        throw new Error('array item 1 must be a variable or expression');\n      }\n    } else {\n      throw new Error('invalid Expression argument: ' + item);\n    }\n  }\n  return { terms, constant };\n}\n","/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\n\n/**\n * @class Strength\n */\nexport class Strength {\n  /**\n   * Create a new symbolic strength.\n   *\n   * @param a strong\n   * @param b medium\n   * @param c weak\n   * @param [w] weight\n   * @return strength\n   */\n  static create(a: number, b: number, c: number, w: number = 1.0) {\n    let result: number = 0.0;\n    result += Math.max(0.0, Math.min(1000.0, a * w)) * 1000000.0;\n    result += Math.max(0.0, Math.min(1000.0, b * w)) * 1000.0;\n    result += Math.max(0.0, Math.min(1000.0, c * w));\n    return result;\n  }\n\n  /**\n   * The 'required' symbolic strength.\n   */\n  static required = Strength.create(1000.0, 1000.0, 1000.0);\n\n  /**\n   * The 'strong' symbolic strength.\n   */\n  static strong = Strength.create(1.0, 0.0, 0.0);\n\n  /**\n   * The 'medium' symbolic strength.\n   */\n  static medium = Strength.create(0.0, 1.0, 0.0);\n\n  /**\n   * The 'weak' symbolic strength.\n   */\n  static weak = Strength.create(0.0, 0.0, 1.0);\n\n  /**\n   * Clip a symbolic strength to the allowed min and max.\n   * @private\n   */\n  static clip(value: number) {\n    return Math.max(0.0, Math.min(Strength.required, value));\n  }\n}\n","/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\n\nimport { Expression } from './expression';\nimport { Strength } from './strength';\nimport { Variable } from './variable';\n\n/**\n * An enum defining the linear constraint operators.\n *\n * |Value|Operator|Description|\n * |----|-----|-----|\n * |`Le`|<=|Less than equal|\n * |`Ge`|>=|Greater than equal|\n * |`Eq`|==|Equal|\n *\n * @enum {Number}\n */\nexport enum Operator {\n  Le, // <=\n  Ge, // >=\n  Eq // ==\n}\n\n/**\n * A linear constraint equation.\n *\n * A constraint equation is composed of an expression, an operator,\n * and a strength. The RHS of the equation is implicitly zero.\n *\n * @class\n * @param {Expression} expression The constraint expression (LHS).\n * @param {Operator} operator The equation operator.\n * @param {Expression} [rhs] Right hand side of the expression.\n * @param {Number} [strength=Strength.required] The strength of the constraint.\n */\nexport class Constraint {\n  constructor(\n    expression: Expression | Variable,\n    operator: Operator,\n    rhs?: Expression | Variable | number,\n    strength: number = Strength.required\n  ) {\n    this._operator = operator;\n    this._strength = Strength.clip(strength);\n    if (rhs === undefined && expression instanceof Expression) {\n      this._expression = expression;\n    } else {\n      this._expression = expression.minus(rhs);\n    }\n  }\n\n  /**\n   * Returns the unique id number of the constraint.\n   * @private\n   */\n  public id(): number {\n    return this._id;\n  }\n\n  /**\n   * Returns the expression of the constraint.\n   *\n   * @return {Expression} expression\n   */\n  public expression(): Expression {\n    return this._expression;\n  }\n\n  /**\n   * Returns the relational operator of the constraint.\n   *\n   * @return {Operator} linear constraint operator\n   */\n  public op(): Operator {\n    return this._operator;\n  }\n\n  /**\n   * Returns the strength of the constraint.\n   *\n   * @return {Number} strength\n   */\n  public strength(): number {\n    return this._strength;\n  }\n\n  public toString(): string {\n    return (\n      this._expression.toString() +\n      ' ' +\n      ['<=', '>=', '='][this._operator] +\n      ' 0 (' +\n      this._strength.toString() +\n      ')'\n    );\n  }\n\n  private _expression: Expression;\n  private _operator: Operator;\n  private _strength: number;\n  private _id: number = CnId++;\n}\n\n/**\n * The internal constraint id counter.\n * @private\n */\nlet CnId = 0;\n","/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\n\nexport interface IMap<T extends { id(): number }, U> extends IndexedMap<T, U> {}\n\nexport function createMap<T extends { id(): number }, U>(): IMap<T, U> {\n  return new IndexedMap<T, U>();\n}\n\nclass IndexedMap<T extends { id(): number }, U> {\n  public index = {} as { [id: number]: number | undefined };\n  public array = [] as Array<Pair<T, U>>;\n\n  /**\n   * Returns the number of items in the array.\n   */\n  public size(): number {\n    return this.array.length;\n  }\n\n  /**\n   * Returns true if the array is empty.\n   */\n  public empty(): boolean {\n    return this.array.length === 0;\n  }\n\n  /**\n   * Returns the item at the given array index.\n   *\n   * @param index The integer index of the desired item.\n   */\n  public itemAt(index: number): Pair<T, U> {\n    return this.array[index];\n  }\n\n  /**\n   * Returns true if the key is in the array, false otherwise.\n   *\n   * @param key The key to locate in the array.\n   */\n  public contains(key: T) {\n    return this.index[key.id()] !== undefined;\n  }\n\n  /**\n   * Returns the pair associated with the given key, or undefined.\n   *\n   * @param key The key to locate in the array.\n   */\n  public find(key: T) {\n    const i = this.index[key.id()];\n    return i === undefined ? undefined : this.array[i];\n  }\n\n  /**\n   * Returns the pair associated with the key if it exists.\n   *\n   * If the key does not exist, a new pair will be created and\n   * inserted using the value created by the given factory.\n   *\n   * @param key The key to locate in the array.\n   * @param factory The function which creates the default value.\n   */\n  public setDefault(key: T, factory: () => U): Pair<T, U> {\n    const i = this.index[key.id()];\n    if (i === undefined) {\n      const pair = new Pair(key, factory());\n      this.index[key.id()] = this.array.length;\n      this.array.push(pair);\n      return pair;\n    } else {\n      return this.array[i];\n    }\n  }\n\n  /**\n   * Insert the pair into the array and return the pair.\n   *\n   * This will overwrite any existing entry in the array.\n   *\n   * @param key The key portion of the pair.\n   * @param value The value portion of the pair.\n   */\n  public insert(key: T, value: U): Pair<T, U> {\n    const pair = new Pair(key, value);\n    const i = this.index[key.id()];\n    if (i === undefined) {\n      this.index[key.id()] = this.array.length;\n      this.array.push(pair);\n    } else {\n      this.array[i] = pair;\n    }\n    return pair;\n  }\n\n  /**\n   * Removes and returns the pair for the given key, or undefined.\n   *\n   * @param key The key to remove from the map.\n   */\n  public erase(key: T): Pair<T, U> {\n    const i = this.index[key.id()];\n    if (i === undefined) {\n      return undefined;\n    }\n    this.index[key.id()] = undefined;\n    const pair = this.array[i];\n    const last = this.array.pop();\n    if (pair !== last) {\n      this.array[i] = last;\n      this.index[last.first.id()] = i;\n    }\n    return pair;\n  }\n\n  /**\n   * Create a copy of this associative array.\n   */\n  public copy(): IndexedMap<T, U> {\n    const copy = new IndexedMap<T, U>();\n    for (let i = 0; i < this.array.length; i++) {\n      const pair = this.array[i].copy();\n      copy.array[i] = pair;\n      copy.index[pair.first.id()] = i;\n    }\n    return copy;\n  }\n}\n\n/**\n * A class which defines a generic pair object.\n * @private\n */\n// tslint:disable: max-classes-per-file\nclass Pair<T, U> {\n  /**\n   * Construct a new Pair object.\n   *\n   * @param first The first item of the pair.\n   * @param second The second item of the pair.\n   */\n  constructor(public first: T, public second: U) {}\n\n  /**\n   * Create a copy of the pair.\n   */\n  public copy() {\n    return new Pair(this.first, this.second);\n  }\n}\n","/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\n\nimport { Expression } from './expression';\n\n/**\n * The primary user constraint variable.\n *\n * @class\n * @param {String} [name=\"\"] The name to associated with the variable.\n */\nexport class Variable {\n  constructor(name: string = '') {\n    this._name = name;\n  }\n\n  /**\n   * Returns the unique id number of the variable.\n   * @private\n   */\n  public id(): number {\n    return this._id;\n  }\n\n  /**\n   * Returns the name of the variable.\n   *\n   * @return {String} name of the variable\n   */\n  public name(): string {\n    return this._name;\n  }\n\n  /**\n   * Set the name of the variable.\n   *\n   * @param {String} name Name of the variable\n   */\n  public setName(name: string): void {\n    this._name = name;\n  }\n\n  /**\n   * Returns the user context object of the variable.\n   * @private\n   */\n  public context(): any {\n    return this._context;\n  }\n\n  /**\n   * Set the user context object of the variable.\n   * @private\n   */\n  public setContext(context: any): void {\n    this._context = context;\n  }\n\n  /**\n   * Returns the value of the variable.\n   *\n   * @return {Number} Calculated value\n   */\n  public value(): number {\n    return this._value;\n  }\n\n  /**\n   * Set the value of the variable.\n   * @private\n   */\n  public setValue(value: number): void {\n    this._value = value;\n  }\n\n  /**\n   * Creates a new Expression by adding a number, variable or expression\n   * to the variable.\n   *\n   * @param {Number|Variable|Expression} value Value to add.\n   * @return {Expression} expression\n   */\n  public plus(value: number | Variable | Expression): Expression {\n    return new Expression(this, value);\n  }\n\n  /**\n   * Creates a new Expression by substracting a number, variable or expression\n   * from the variable.\n   *\n   * @param {Number|Variable|Expression} value Value to substract.\n   * @return {Expression} expression\n   */\n  public minus(value: number | Variable | Expression): Expression {\n    return new Expression(\n      this,\n      typeof value === 'number' ? -value : [-1, value]\n    );\n  }\n\n  /**\n   * Creates a new Expression by multiplying with a fixed number.\n   *\n   * @param {Number} coefficient Coefficient to multiply with.\n   * @return {Expression} expression\n   */\n  public multiply(coefficient: number): Expression {\n    return new Expression([coefficient, this]);\n  }\n\n  /**\n   * Creates a new Expression by dividing with a fixed number.\n   *\n   * @param {Number} coefficient Coefficient to divide by.\n   * @return {Expression} expression\n   */\n  public divide(coefficient: number): Expression {\n    return new Expression([1 / coefficient, this]);\n  }\n\n  /**\n   * Returns the JSON representation of the variable.\n   * @private\n   */\n  public toJSON(): any {\n    return {\n      name: this._name,\n      value: this._value\n    };\n  }\n\n  public toString(): string {\n    return this._context + '[' + this._name + ':' + this._value + ']';\n  }\n\n  private _name: string;\n  private _value: number = 0.0;\n  private _context: any = null;\n  private _id: number = VarId++;\n}\n\n/**\n * The internal variable id counter.\n * @private\n */\nlet VarId = 0;\n","/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2018, Nucleic Development Team & H. Rutjes.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\n\nexport * from './constraint';\nexport * from './expression';\nexport * from './solver';\nexport * from './strength';\nexport * from './variable';\n","/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\n\nimport { Constraint, Operator } from './constraint';\nimport { Expression } from './expression';\nimport { createMap, IMap } from './maptype';\nimport { Strength } from './strength';\nimport { Variable } from './variable';\n\n/**\n * The constraint solver class.\n *\n * @class\n */\nexport class Solver {\n  /**\n   * Construct a new Solver.\n   */\n  constructor() {}\n\n  /**\n   * Creates and add a constraint to the solver.\n   *\n   * @param {Expression|Variable} lhs Left hand side of the expression\n   * @param {Operator} operator Operator\n   * @param {Expression|Variable|Number} rhs Right hand side of the expression\n   * @param {Number} [strength=Strength.required] Strength\n   */\n  public createConstraint(\n    lhs: Expression | Variable,\n    operator: Operator,\n    rhs: Expression | Variable | number,\n    strength: number = Strength.required\n  ): Constraint {\n    let cn = new Constraint(lhs, operator, rhs, strength);\n    this.addConstraint(cn);\n    return cn;\n  }\n\n  /**\n   * Add a constraint to the solver.\n   *\n   * @param {Constraint} constraint Constraint to add to the solver\n   */\n  public addConstraint(constraint: Constraint): void {\n    let cnPair = this._cnMap.find(constraint);\n    if (cnPair !== undefined) {\n      throw new Error('duplicate constraint');\n    }\n\n    // Creating a row causes symbols to be reserved for the variables\n    // in the constraint. If this method exits with an exception,\n    // then its possible those variables will linger in the var map.\n    // Since its likely that those variables will be used in other\n    // constraints and since exceptional conditions are uncommon,\n    // i'm not too worried about aggressive cleanup of the var map.\n    let data = this._createRow(constraint);\n    let row = data.row;\n    let tag = data.tag;\n    let subject = this._chooseSubject(row, tag);\n\n    // If chooseSubject couldnt find a valid entering symbol, one\n    // last option is available if the entire row is composed of\n    // dummy variables. If the constant of the row is zero, then\n    // this represents redundant constraints and the new dummy\n    // marker can enter the basis. If the constant is non-zero,\n    // then it represents an unsatisfiable constraint.\n    if (subject.type() === SymbolType.Invalid && row.allDummies()) {\n      if (!nearZero(row.constant())) {\n        throw new Error('unsatisfiable constraint');\n      } else {\n        subject = tag.marker;\n      }\n    }\n\n    // If an entering symbol still isn't found, then the row must\n    // be added using an artificial variable. If that fails, then\n    // the row represents an unsatisfiable constraint.\n    if (subject.type() === SymbolType.Invalid) {\n      if (!this._addWithArtificialVariable(row)) {\n        throw new Error('unsatisfiable constraint');\n      }\n    } else {\n      row.solveFor(subject);\n      this._substitute(subject, row);\n      this._rowMap.insert(subject, row);\n    }\n\n    this._cnMap.insert(constraint, tag);\n\n    // Optimizing after each constraint is added performs less\n    // aggregate work due to a smaller average system size. It\n    // also ensures the solver remains in a consistent state.\n    this._optimize(this._objective);\n  }\n\n  /**\n   * Remove a constraint from the solver.\n   *\n   * @param {Constraint} constraint Constraint to remove from the solver\n   */\n  public removeConstraint(constraint: Constraint): void {\n    let cnPair = this._cnMap.erase(constraint);\n    if (cnPair === undefined) {\n      throw new Error('unknown constraint');\n    }\n\n    // Remove the error effects from the objective function\n    // *before* pivoting, or substitutions into the objective\n    // will lead to incorrect solver results.\n    this._removeConstraintEffects(constraint, cnPair.second);\n\n    // If the marker is basic, simply drop the row. Otherwise,\n    // pivot the marker into the basis and then drop the row.\n    let marker = cnPair.second.marker;\n    let rowPair = this._rowMap.erase(marker);\n    if (rowPair === undefined) {\n      let leaving = this._getMarkerLeavingSymbol(marker);\n      if (leaving.type() === SymbolType.Invalid) {\n        throw new Error('failed to find leaving row');\n      }\n      rowPair = this._rowMap.erase(leaving);\n      rowPair.second.solveForEx(leaving, marker);\n      this._substitute(marker, rowPair.second);\n    }\n\n    // Optimizing after each constraint is removed ensures that the\n    // solver remains consistent. It makes the solver api easier to\n    // use at a small tradeoff for speed.\n    this._optimize(this._objective);\n  }\n\n  /**\n   * Test whether the solver contains the constraint.\n   *\n   * @param {Constraint} constraint Constraint to test for\n   * @return {Bool} true or false\n   */\n  public hasConstraint(constraint: Constraint): boolean {\n    return this._cnMap.contains(constraint);\n  }\n\n  /**\n   * Add an edit variable to the solver.\n   *\n   * @param {Variable} variable Edit variable to add to the solver\n   * @param {Number} strength Strength, should be less than `Strength.required`\n   */\n  public addEditVariable(variable: Variable, strength: number): void {\n    let editPair = this._editMap.find(variable);\n    if (editPair !== undefined) {\n      throw new Error('duplicate edit variable');\n    }\n    strength = Strength.clip(strength);\n    if (strength === Strength.required) {\n      throw new Error('bad required strength');\n    }\n    let expr = new Expression(variable);\n    let cn = new Constraint(expr, Operator.Eq, undefined, strength);\n    this.addConstraint(cn);\n    let tag = this._cnMap.find(cn).second;\n    let info = { tag, constraint: cn, constant: 0.0 };\n    this._editMap.insert(variable, info);\n  }\n\n  /**\n   * Remove an edit variable from the solver.\n   *\n   * @param {Variable} variable Edit variable to remove from the solver\n   */\n  public removeEditVariable(variable: Variable): void {\n    let editPair = this._editMap.erase(variable);\n    if (editPair === undefined) {\n      throw new Error('unknown edit variable');\n    }\n    this.removeConstraint(editPair.second.constraint);\n  }\n\n  /**\n   * Test whether the solver contains the edit variable.\n   *\n   * @param {Variable} variable Edit variable to test for\n   * @return {Bool} true or false\n   */\n  public hasEditVariable(variable: Variable): boolean {\n    return this._editMap.contains(variable);\n  }\n\n  /**\n   * Suggest the value of an edit variable.\n   *\n   * @param {Variable} variable Edit variable to suggest a value for\n   * @param {Number} value Suggested value\n   */\n  public suggestValue(variable: Variable, value: number): void {\n    let editPair = this._editMap.find(variable);\n    if (editPair === undefined) {\n      throw new Error('unknown edit variable');\n    }\n\n    let rows = this._rowMap;\n    let info = editPair.second;\n    let delta = value - info.constant;\n    info.constant = value;\n\n    // Check first if the positive error variable is basic.\n    let marker = info.tag.marker;\n    let rowPair = rows.find(marker);\n    if (rowPair !== undefined) {\n      if (rowPair.second.add(-delta) < 0.0) {\n        this._infeasibleRows.push(marker);\n      }\n      this._dualOptimize();\n      return;\n    }\n\n    // Check next if the negative error variable is basic.\n    let other = info.tag.other;\n    rowPair = rows.find(other);\n    if (rowPair !== undefined) {\n      if (rowPair.second.add(delta) < 0.0) {\n        this._infeasibleRows.push(other);\n      }\n      this._dualOptimize();\n      return;\n    }\n\n    // Otherwise update each row where the error variables exist.\n    for (let i = 0, n = rows.size(); i < n; ++i) {\n      let rowPair = rows.itemAt(i);\n      let row = rowPair.second;\n      let coeff = row.coefficientFor(marker);\n      if (\n        coeff !== 0.0 &&\n        row.add(delta * coeff) < 0.0 &&\n        rowPair.first.type() !== SymbolType.External\n      ) {\n        this._infeasibleRows.push(rowPair.first);\n      }\n    }\n    this._dualOptimize();\n  }\n\n  /**\n   * Update the values of the variables.\n   */\n  public updateVariables(): void {\n    let vars = this._varMap;\n    let rows = this._rowMap;\n    for (let i = 0, n = vars.size(); i < n; ++i) {\n      let pair = vars.itemAt(i);\n      let rowPair = rows.find(pair.second);\n      if (rowPair !== undefined) {\n        pair.first.setValue(rowPair.second.constant());\n      } else {\n        pair.first.setValue(0.0);\n      }\n    }\n  }\n\n  /**\n   * Get the symbol for the given variable.\n   *\n   * If a symbol does not exist for the variable, one will be created.\n   * @private\n   */\n  private _getVarSymbol(variable: Variable): Symbol {\n    let factory = () => this._makeSymbol(SymbolType.External);\n    return this._varMap.setDefault(variable, factory).second;\n  }\n\n  /**\n   * Create a new Row object for the given constraint.\n   *\n   * The terms in the constraint will be converted to cells in the row.\n   * Any term in the constraint with a coefficient of zero is ignored.\n   * This method uses the `_getVarSymbol` method to get the symbol for\n   * the variables added to the row. If the symbol for a given cell\n   * variable is basic, the cell variable will be substituted with the\n   * basic row.\n   *\n   * The necessary slack and error variables will be added to the row.\n   * If the constant for the row is negative, the sign for the row\n   * will be inverted so the constant becomes positive.\n   *\n   * Returns the created Row and the tag for tracking the constraint.\n   * @private\n   */\n  private _createRow(constraint: Constraint): IRowCreation {\n    let expr = constraint.expression();\n    let row = new Row(expr.constant());\n\n    // Substitute the current basic variables into the row.\n    let terms = expr.terms();\n    for (let i = 0, n = terms.size(); i < n; ++i) {\n      let termPair = terms.itemAt(i);\n      if (!nearZero(termPair.second)) {\n        let symbol = this._getVarSymbol(termPair.first);\n        let basicPair = this._rowMap.find(symbol);\n        if (basicPair !== undefined) {\n          row.insertRow(basicPair.second, termPair.second);\n        } else {\n          row.insertSymbol(symbol, termPair.second);\n        }\n      }\n    }\n\n    // Add the necessary slack, error, and dummy variables.\n    let objective = this._objective;\n    let strength = constraint.strength();\n    let tag = { marker: INVALID_SYMBOL, other: INVALID_SYMBOL };\n    switch (constraint.op()) {\n      case Operator.Le:\n      case Operator.Ge: {\n        let coeff = constraint.op() === Operator.Le ? 1.0 : -1.0;\n        let slack = this._makeSymbol(SymbolType.Slack);\n        tag.marker = slack;\n        row.insertSymbol(slack, coeff);\n        if (strength < Strength.required) {\n          let error = this._makeSymbol(SymbolType.Error);\n          tag.other = error;\n          row.insertSymbol(error, -coeff);\n          objective.insertSymbol(error, strength);\n        }\n        break;\n      }\n      case Operator.Eq: {\n        if (strength < Strength.required) {\n          let errplus = this._makeSymbol(SymbolType.Error);\n          let errminus = this._makeSymbol(SymbolType.Error);\n          tag.marker = errplus;\n          tag.other = errminus;\n          row.insertSymbol(errplus, -1.0); // v = eplus - eminus\n          row.insertSymbol(errminus, 1.0); // v - eplus + eminus = 0\n          objective.insertSymbol(errplus, strength);\n          objective.insertSymbol(errminus, strength);\n        } else {\n          let dummy = this._makeSymbol(SymbolType.Dummy);\n          tag.marker = dummy;\n          row.insertSymbol(dummy);\n        }\n        break;\n      }\n    }\n\n    // Ensure the row has a positive constant.\n    if (row.constant() < 0.0) {\n      row.reverseSign();\n    }\n\n    return { row, tag };\n  }\n\n  /**\n   * Choose the subject for solving for the row.\n   *\n   * This method will choose the best subject for using as the solve\n   * target for the row. An invalid symbol will be returned if there\n   * is no valid target.\n   *\n   * The symbols are chosen according to the following precedence:\n   *\n   * 1) The first symbol representing an external variable.\n   * 2) A negative slack or error tag variable.\n   *\n   * If a subject cannot be found, an invalid symbol will be returned.\n   *\n   * @private\n   */\n  private _chooseSubject(row: Row, tag: ITag): Symbol {\n    let cells = row.cells();\n    for (let i = 0, n = cells.size(); i < n; ++i) {\n      let pair = cells.itemAt(i);\n      if (pair.first.type() === SymbolType.External) {\n        return pair.first;\n      }\n    }\n    let type = tag.marker.type();\n    if (type === SymbolType.Slack || type === SymbolType.Error) {\n      if (row.coefficientFor(tag.marker) < 0.0) {\n        return tag.marker;\n      }\n    }\n    type = tag.other.type();\n    if (type === SymbolType.Slack || type === SymbolType.Error) {\n      if (row.coefficientFor(tag.other) < 0.0) {\n        return tag.other;\n      }\n    }\n    return INVALID_SYMBOL;\n  }\n\n  /**\n   * Add the row to the tableau using an artificial variable.\n   *\n   * This will return false if the constraint cannot be satisfied.\n   *\n   * @private\n   */\n  private _addWithArtificialVariable(row: Row): boolean {\n    // Create and add the artificial variable to the tableau.\n    let art = this._makeSymbol(SymbolType.Slack);\n    this._rowMap.insert(art, row.copy());\n    this._artificial = row.copy();\n\n    // Optimize the artificial objective. This is successful\n    // only if the artificial objective is optimized to zero.\n    this._optimize(this._artificial);\n    let success = nearZero(this._artificial.constant());\n    this._artificial = null;\n\n    // If the artificial variable is basic, pivot the row so that\n    // it becomes non-basic. If the row is constant, exit early.\n    let pair = this._rowMap.erase(art);\n    if (pair !== undefined) {\n      let basicRow = pair.second;\n      if (basicRow.isConstant()) {\n        return success;\n      }\n      let entering = this._anyPivotableSymbol(basicRow);\n      if (entering.type() === SymbolType.Invalid) {\n        return false; // unsatisfiable (will this ever happen?)\n      }\n      basicRow.solveForEx(art, entering);\n      this._substitute(entering, basicRow);\n      this._rowMap.insert(entering, basicRow);\n    }\n\n    // Remove the artificial variable from the tableau.\n    let rows = this._rowMap;\n    for (let i = 0, n = rows.size(); i < n; ++i) {\n      rows.itemAt(i).second.removeSymbol(art);\n    }\n    this._objective.removeSymbol(art);\n    return success;\n  }\n\n  /**\n   * Substitute the parametric symbol with the given row.\n   *\n   * This method will substitute all instances of the parametric symbol\n   * in the tableau and the objective function with the given row.\n   *\n   * @private\n   */\n  private _substitute(symbol: Symbol, row: Row): void {\n    let rows = this._rowMap;\n    for (let i = 0, n = rows.size(); i < n; ++i) {\n      let pair = rows.itemAt(i);\n      pair.second.substitute(symbol, row);\n      if (\n        pair.second.constant() < 0.0 &&\n        pair.first.type() !== SymbolType.External\n      ) {\n        this._infeasibleRows.push(pair.first);\n      }\n    }\n    this._objective.substitute(symbol, row);\n    if (this._artificial) {\n      this._artificial.substitute(symbol, row);\n    }\n  }\n\n  /**\n   * Optimize the system for the given objective function.\n   *\n   * This method performs iterations of Phase 2 of the simplex method\n   * until the objective function reaches a minimum.\n   *\n   * @private\n   */\n  private _optimize(objective: Row): void {\n    while (true) {\n      let entering = this._getEnteringSymbol(objective);\n      if (entering.type() === SymbolType.Invalid) {\n        return;\n      }\n      let leaving = this._getLeavingSymbol(entering);\n      if (leaving.type() === SymbolType.Invalid) {\n        throw new Error('the objective is unbounded');\n      }\n      // pivot the entering symbol into the basis\n      let row = this._rowMap.erase(leaving).second;\n      row.solveForEx(leaving, entering);\n      this._substitute(entering, row);\n      this._rowMap.insert(entering, row);\n    }\n  }\n\n  /**\n   * Optimize the system using the dual of the simplex method.\n   *\n   * The current state of the system should be such that the objective\n   * function is optimal, but not feasible. This method will perform\n   * an iteration of the dual simplex method to make the solution both\n   * optimal and feasible.\n   *\n   * @private\n   */\n  private _dualOptimize(): void {\n    let rows = this._rowMap;\n    let infeasible = this._infeasibleRows;\n    while (infeasible.length !== 0) {\n      let leaving = infeasible.pop();\n      let pair = rows.find(leaving);\n      if (pair !== undefined && pair.second.constant() < 0.0) {\n        let entering = this._getDualEnteringSymbol(pair.second);\n        if (entering.type() === SymbolType.Invalid) {\n          throw new Error('dual optimize failed');\n        }\n        // pivot the entering symbol into the basis\n        let row = pair.second;\n        rows.erase(leaving);\n        row.solveForEx(leaving, entering);\n        this._substitute(entering, row);\n        rows.insert(entering, row);\n      }\n    }\n  }\n\n  /**\n   * Compute the entering variable for a pivot operation.\n   *\n   * This method will return first symbol in the objective function which\n   * is non-dummy and has a coefficient less than zero. If no symbol meets\n   * the criteria, it means the objective function is at a minimum, and an\n   * invalid symbol is returned.\n   *\n   * @private\n   */\n  private _getEnteringSymbol(objective: Row): Symbol {\n    let cells = objective.cells();\n    for (let i = 0, n = cells.size(); i < n; ++i) {\n      let pair = cells.itemAt(i);\n      let symbol = pair.first;\n      if (pair.second < 0.0 && symbol.type() !== SymbolType.Dummy) {\n        return symbol;\n      }\n    }\n    return INVALID_SYMBOL;\n  }\n\n  /**\n   * Compute the entering symbol for the dual optimize operation.\n   *\n   * This method will return the symbol in the row which has a positive\n   * coefficient and yields the minimum ratio for its respective symbol\n   * in the objective function. The provided row *must* be infeasible.\n   * If no symbol is found which meats the criteria, an invalid symbol\n   * is returned.\n   *\n   * @private\n   */\n  private _getDualEnteringSymbol(row: Row): Symbol {\n    let ratio = Number.MAX_VALUE;\n    let entering = INVALID_SYMBOL;\n    let cells = row.cells();\n    for (let i = 0, n = cells.size(); i < n; ++i) {\n      let pair = cells.itemAt(i);\n      let symbol = pair.first;\n      let c = pair.second;\n      if (c > 0.0 && symbol.type() !== SymbolType.Dummy) {\n        let coeff = this._objective.coefficientFor(symbol);\n        let r = coeff / c;\n        if (r < ratio) {\n          ratio = r;\n          entering = symbol;\n        }\n      }\n    }\n    return entering;\n  }\n\n  /**\n   * Compute the symbol for pivot exit row.\n   *\n   * This method will return the symbol for the exit row in the row\n   * map. If no appropriate exit symbol is found, an invalid symbol\n   * will be returned. This indicates that the objective function is\n   * unbounded.\n   *\n   * @private\n   */\n  private _getLeavingSymbol(entering: Symbol): Symbol {\n    let ratio = Number.MAX_VALUE;\n    let found = INVALID_SYMBOL;\n    let rows = this._rowMap;\n    for (let i = 0, n = rows.size(); i < n; ++i) {\n      let pair = rows.itemAt(i);\n      let symbol = pair.first;\n      if (symbol.type() !== SymbolType.External) {\n        let row = pair.second;\n        let temp = row.coefficientFor(entering);\n        if (temp < 0.0) {\n          let temp_ratio = -row.constant() / temp;\n          if (temp_ratio < ratio) {\n            ratio = temp_ratio;\n            found = symbol;\n          }\n        }\n      }\n    }\n    return found;\n  }\n\n  /**\n   * Compute the leaving symbol for a marker variable.\n   *\n   * This method will return a symbol corresponding to a basic row\n   * which holds the given marker variable. The row will be chosen\n   * according to the following precedence:\n   *\n   * 1) The row with a restricted basic varible and a negative coefficient\n   *    for the marker with the smallest ratio of -constant / coefficient.\n   *\n   * 2) The row with a restricted basic variable and the smallest ratio\n   *    of constant / coefficient.\n   *\n   * 3) The last unrestricted row which contains the marker.\n   *\n   * If the marker does not exist in any row, an invalid symbol will be\n   * returned. This indicates an internal solver error since the marker\n   * *should* exist somewhere in the tableau.\n   *\n   * @private\n   */\n  private _getMarkerLeavingSymbol(marker: Symbol): Symbol {\n    let dmax = Number.MAX_VALUE;\n    let r1 = dmax;\n    let r2 = dmax;\n    let invalid = INVALID_SYMBOL;\n    let first = invalid;\n    let second = invalid;\n    let third = invalid;\n    let rows = this._rowMap;\n    for (let i = 0, n = rows.size(); i < n; ++i) {\n      let pair = rows.itemAt(i);\n      let row = pair.second;\n      let c = row.coefficientFor(marker);\n      if (c === 0.0) {\n        continue;\n      }\n      let symbol = pair.first;\n      if (symbol.type() === SymbolType.External) {\n        third = symbol;\n      } else if (c < 0.0) {\n        let r = -row.constant() / c;\n        if (r < r1) {\n          r1 = r;\n          first = symbol;\n        }\n      } else {\n        let r = row.constant() / c;\n        if (r < r2) {\n          r2 = r;\n          second = symbol;\n        }\n      }\n    }\n    if (first !== invalid) {\n      return first;\n    }\n    if (second !== invalid) {\n      return second;\n    }\n    return third;\n  }\n\n  /**\n   * Remove the effects of a constraint on the objective function.\n   *\n   * @private\n   */\n  private _removeConstraintEffects(cn: Constraint, tag: ITag): void {\n    if (tag.marker.type() === SymbolType.Error) {\n      this._removeMarkerEffects(tag.marker, cn.strength());\n    }\n    if (tag.other.type() === SymbolType.Error) {\n      this._removeMarkerEffects(tag.other, cn.strength());\n    }\n  }\n\n  /**\n   * Remove the effects of an error marker on the objective function.\n   *\n   * @private\n   */\n  private _removeMarkerEffects(marker: Symbol, strength: number): void {\n    let pair = this._rowMap.find(marker);\n    if (pair !== undefined) {\n      this._objective.insertRow(pair.second, -strength);\n    } else {\n      this._objective.insertSymbol(marker, -strength);\n    }\n  }\n\n  /**\n   * Get the first Slack or Error symbol in the row.\n   *\n   * If no such symbol is present, an invalid symbol will be returned.\n   *\n   * @private\n   */\n  private _anyPivotableSymbol(row: Row): Symbol {\n    let cells = row.cells();\n    for (let i = 0, n = cells.size(); i < n; ++i) {\n      let pair = cells.itemAt(i);\n      let type = pair.first.type();\n      if (type === SymbolType.Slack || type === SymbolType.Error) {\n        return pair.first;\n      }\n    }\n    return INVALID_SYMBOL;\n  }\n\n  /**\n   * Returns a new Symbol of the given type.\n   *\n   * @private\n   */\n  private _makeSymbol(type: SymbolType): Symbol {\n    return new Symbol(type, this._idTick++);\n  }\n\n  private _cnMap = createCnMap();\n  private _rowMap = createRowMap();\n  private _varMap = createVarMap();\n  private _editMap = createEditMap();\n  private _infeasibleRows: Symbol[] = [];\n  private _objective: Row = new Row();\n  private _artificial: Row = null;\n  private _idTick: number = 0;\n}\n\n/**\n * Test whether a value is approximately zero.\n * @private\n */\nfunction nearZero(value: number): boolean {\n  let eps = 1.0e-8;\n  return value < 0.0 ? -value < eps : value < eps;\n}\n\n/**\n * The internal interface of a tag value.\n */\ninterface ITag {\n  marker: Symbol;\n  other: Symbol;\n}\n\n/**\n * The internal interface of an edit info object.\n */\ninterface IEditInfo {\n  tag: ITag;\n  constraint: Constraint;\n  constant: number;\n}\n\n/**\n * The internal interface for returning created row data.\n */\ninterface IRowCreation {\n  row: Row;\n  tag: ITag;\n}\n\n/**\n * An internal function for creating a constraint map.\n * @private\n */\nfunction createCnMap(): IMap<Constraint, ITag> {\n  return createMap<Constraint, ITag>();\n}\n\n/**\n * An internal function for creating a row map.\n * @private\n */\nfunction createRowMap(): IMap<Symbol, Row> {\n  return createMap<Symbol, Row>();\n}\n\n/**\n * An internal function for creating a variable map.\n * @private\n */\nfunction createVarMap(): IMap<Variable, Symbol> {\n  return createMap<Variable, Symbol>();\n}\n\n/**\n * An internal function for creating an edit map.\n * @private\n */\nfunction createEditMap(): IMap<Variable, IEditInfo> {\n  return createMap<Variable, IEditInfo>();\n}\n\n/**\n * An enum defining the available symbol types.\n * @private\n */\nenum SymbolType {\n  Invalid,\n  External,\n  Slack,\n  Error,\n  Dummy\n}\n\n/**\n * An internal class representing a symbol in the solver.\n * @private\n */\nclass Symbol {\n  /**\n   * Construct a new Symbol\n   *\n   * @param [type] The type of the symbol.\n   * @param [id] The unique id number of the symbol.\n   */\n  constructor(type: SymbolType, id: number) {\n    this._id = id;\n    this._type = type;\n  }\n\n  /**\n   * Returns the unique id number of the symbol.\n   */\n  public id(): number {\n    return this._id;\n  }\n\n  /**\n   * Returns the type of the symbol.\n   */\n  public type(): SymbolType {\n    return this._type;\n  }\n\n  private _id: number;\n  private _type: SymbolType;\n}\n\n/**\n * A static invalid symbol\n * @private\n */\nlet INVALID_SYMBOL = new Symbol(SymbolType.Invalid, -1);\n\n/**\n * An internal row class used by the solver.\n * @private\n */\nclass Row {\n  /**\n   * Construct a new Row.\n   */\n  constructor(constant: number = 0.0) {\n    this._constant = constant;\n  }\n\n  /**\n   * Returns the mapping of symbols to coefficients.\n   */\n  public cells(): IMap<Symbol, number> {\n    return this._cellMap;\n  }\n\n  /**\n   * Returns the constant for the row.\n   */\n  public constant(): number {\n    return this._constant;\n  }\n\n  /**\n   * Returns true if the row is a constant value.\n   */\n  public isConstant(): boolean {\n    return this._cellMap.empty();\n  }\n\n  /**\n   * Returns true if the Row has all dummy symbols.\n   */\n  public allDummies(): boolean {\n    let cells = this._cellMap;\n    for (let i = 0, n = cells.size(); i < n; ++i) {\n      let pair = cells.itemAt(i);\n      if (pair.first.type() !== SymbolType.Dummy) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Create a copy of the row.\n   */\n  public copy(): Row {\n    let theCopy = new Row(this._constant);\n    theCopy._cellMap = this._cellMap.copy();\n    return theCopy;\n  }\n\n  /**\n   * Add a constant value to the row constant.\n   *\n   * Returns the new value of the constant.\n   */\n  public add(value: number): number {\n    return (this._constant += value);\n  }\n\n  /**\n   * Insert the symbol into the row with the given coefficient.\n   *\n   * If the symbol already exists in the row, the coefficient\n   * will be added to the existing coefficient. If the resulting\n   * coefficient is zero, the symbol will be removed from the row.\n   */\n  public insertSymbol(symbol: Symbol, coefficient: number = 1.0): void {\n    let pair = this._cellMap.setDefault(symbol, () => 0.0);\n    if (nearZero((pair.second += coefficient))) {\n      this._cellMap.erase(symbol);\n    }\n  }\n\n  /**\n   * Insert a row into this row with a given coefficient.\n   *\n   * The constant and the cells of the other row will be\n   * multiplied by the coefficient and added to this row. Any\n   * cell with a resulting coefficient of zero will be removed\n   * from the row.\n   */\n  public insertRow(other: Row, coefficient: number = 1.0): void {\n    this._constant += other._constant * coefficient;\n    let cells = other._cellMap;\n    for (let i = 0, n = cells.size(); i < n; ++i) {\n      let pair = cells.itemAt(i);\n      this.insertSymbol(pair.first, pair.second * coefficient);\n    }\n  }\n\n  /**\n   * Remove a symbol from the row.\n   */\n  public removeSymbol(symbol: Symbol): void {\n    this._cellMap.erase(symbol);\n  }\n\n  /**\n   * Reverse the sign of the constant and cells in the row.\n   */\n  public reverseSign(): void {\n    this._constant = -this._constant;\n    let cells = this._cellMap;\n    for (let i = 0, n = cells.size(); i < n; ++i) {\n      let pair = cells.itemAt(i);\n      pair.second = -pair.second;\n    }\n  }\n\n  /**\n   * Solve the row for the given symbol.\n   *\n   * This method assumes the row is of the form\n   * a * x + b * y + c = 0 and (assuming solve for x) will modify\n   * the row to represent the right hand side of\n   * x = -b/a * y - c / a. The target symbol will be removed from\n   * the row, and the constant and other cells will be multiplied\n   * by the negative inverse of the target coefficient.\n   *\n   * The given symbol *must* exist in the row.\n   */\n  public solveFor(symbol: Symbol): void {\n    let cells = this._cellMap;\n    let pair = cells.erase(symbol);\n    let coeff = -1.0 / pair.second;\n    this._constant *= coeff;\n    for (let i = 0, n = cells.size(); i < n; ++i) {\n      cells.itemAt(i).second *= coeff;\n    }\n  }\n\n  /**\n   * Solve the row for the given symbols.\n   *\n   * This method assumes the row is of the form\n   * x = b * y + c and will solve the row such that\n   * y = x / b - c / b. The rhs symbol will be removed from the\n   * row, the lhs added, and the result divided by the negative\n   * inverse of the rhs coefficient.\n   *\n   * The lhs symbol *must not* exist in the row, and the rhs\n   * symbol must* exist in the row.\n   */\n  public solveForEx(lhs: Symbol, rhs: Symbol): void {\n    this.insertSymbol(lhs, -1.0);\n    this.solveFor(rhs);\n  }\n\n  /**\n   * Returns the coefficient for the given symbol.\n   */\n  public coefficientFor(symbol: Symbol): number {\n    let pair = this._cellMap.find(symbol);\n    return pair !== undefined ? pair.second : 0.0;\n  }\n\n  /**\n   * Substitute a symbol with the data from another row.\n   *\n   * Given a row of the form a * x + b and a substitution of the\n   * form x = 3 * y + c the row will be updated to reflect the\n   * expression 3 * a * y + a * c + b.\n   *\n   * If the symbol does not exist in the row, this is a no-op.\n   */\n  public substitute(symbol: Symbol, row: Row): void {\n    let pair = this._cellMap.erase(symbol);\n    if (pair !== undefined) {\n      this.insertRow(row, pair.second);\n    }\n  }\n\n  private _cellMap = createMap<Symbol, number>();\n  private _constant: number;\n}\n"],"sourceRoot":""}