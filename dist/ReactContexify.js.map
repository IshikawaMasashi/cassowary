{"version":3,"sources":["webpack://ReactContexify/webpack/universalModuleDefinition","webpack://ReactContexify/webpack/bootstrap","webpack://ReactContexify/./src/expression.ts","webpack://ReactContexify/./src/strength.ts","webpack://ReactContexify/./src/constraint.ts","webpack://ReactContexify/./src/maptype.ts","webpack://ReactContexify/./src/variable.ts","webpack://ReactContexify/./src/index.ts","webpack://ReactContexify/./src/solver.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","parsed","parseArgs","arguments","this","_terms","terms","_constant","constant","result","size","pair","itemAt","first","second","plus","Expression","minus","multiply","coefficient","divide","isConstant","toString","array","map","join","args","createMap","length","item","Variable","setDefault","j","k","terms2","termPair","Array","Error","value2","a","b","w","Math","max","min","clip","Strength","required","strong","medium","weak","Operator","expression","operator","rhs","strength","_id","CnId","_operator","_strength","undefined","_expression","id","op","Constraint","IndexedMap","index","empty","contains","find","Pair","push","insert","erase","last","pop","copy","_value","_context","VarId","_name","setName","context","setContext","setValue","toJSON","SymbolType","_cnMap","_rowMap","_varMap","_editMap","_infeasibleRows","_objective","Row","_artificial","_idTick","createConstraint","lhs","cn","addConstraint","constraint","data","_createRow","row","tag","subject","_chooseSubject","type","Invalid","allDummies","nearZero","marker","_addWithArtificialVariable","solveFor","_substitute","_optimize","removeConstraint","cnPair","_removeConstraintEffects","rowPair","leaving","_getMarkerLeavingSymbol","solveForEx","hasConstraint","addEditVariable","variable","expr","Eq","info","removeEditVariable","editPair","hasEditVariable","suggestValue","rows","delta","add","_dualOptimize","other","coeff","coefficientFor","External","updateVariables","vars","_getVarSymbol","_makeSymbol","symbol","basicPair","insertRow","insertSymbol","objective","INVALID_SYMBOL","Le","Ge","slack","Slack","error","errplus","errminus","dummy","Dummy","reverseSign","cells","art","success","basicRow","entering","_anyPivotableSymbol","removeSymbol","substitute","_getEnteringSymbol","_getLeavingSymbol","infeasible","_getDualEnteringSymbol","ratio","Number","MAX_VALUE","found","temp","temp_ratio","dmax","r1","r2","invalid","third","_removeMarkerEffects","Solver","_type","_cellMap","theCopy"],"mappings":"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","file":"ReactContexify.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactContexify\"] = factory();\n\telse\n\t\troot[\"ReactContexify\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n","/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\n\nimport { createMap, IMap } from './maptype';\nimport { Variable } from './variable';\n\n/**\n * An expression of variable terms and a constant.\n *\n * The constructor accepts an arbitrary number of parameters,\n * each of which must be one of the following types:\n *  - number\n *  - Variable\n *  - Expression\n *  - 2-tuple of [number, Variable|Expression]\n *\n * The parameters are summed. The tuples are multiplied.\n *\n * @class\n * @param {...(number|Variable|Expression|Array)} args\n */\nexport class Expression {\n  constructor(...args: any[]);\n  constructor() {\n    let parsed = parseArgs(arguments);\n    this._terms = parsed.terms;\n    this._constant = parsed.constant;\n  }\n\n  /**\n   * Returns the mapping of terms in the expression.\n   *\n   * This *must* be treated as const.\n   * @private\n   */\n  public terms(): IMap<Variable, number> {\n    return this._terms;\n  }\n\n  /**\n   * Returns the constant of the expression.\n   * @private\n   */\n  public constant(): number {\n    return this._constant;\n  }\n\n  /**\n   * Returns the computed value of the expression.\n   *\n   * @private\n   * @return {Number} computed value of the expression\n   */\n  public value(): number {\n    let result = this._constant;\n    for (let i = 0, n = this._terms.size(); i < n; i++) {\n      let pair = this._terms.itemAt(i);\n      result += pair.first.value() * pair.second;\n    }\n    return result;\n  }\n\n  /**\n   * Creates a new Expression by adding a number, variable or expression\n   * to the expression.\n   *\n   * @param {Number|Variable|Expression} value Value to add.\n   * @return {Expression} expression\n   */\n  public plus(value: number | Variable | Expression): Expression {\n    return new Expression(this, value);\n  }\n\n  /**\n   * Creates a new Expression by substracting a number, variable or expression\n   * from the expression.\n   *\n   * @param {Number|Variable|Expression} value Value to substract.\n   * @return {Expression} expression\n   */\n  public minus(value: number | Variable | Expression): Expression {\n    return new Expression(\n      this,\n      typeof value === 'number' ? -value : [-1, value]\n    );\n  }\n\n  /**\n   * Creates a new Expression by multiplying with a fixed number.\n   *\n   * @param {Number} coefficient Coefficient to multiply with.\n   * @return {Expression} expression\n   */\n  public multiply(coefficient: number): Expression {\n    return new Expression([coefficient, this]);\n  }\n\n  /**\n   * Creates a new Expression by dividing with a fixed number.\n   *\n   * @param {Number} coefficient Coefficient to divide by.\n   * @return {Expression} expression\n   */\n  public divide(coefficient: number): Expression {\n    return new Expression([1 / coefficient, this]);\n  }\n\n  public isConstant(): boolean {\n    return this._terms.size() == 0;\n  }\n\n  public toString(): string {\n    let result = this._terms.array\n      .map(function (pair) {\n        return pair.second + '*' + pair.first.toString();\n      })\n      .join(' + ');\n\n    if (!this.isConstant() && this._constant !== 0) {\n      result += ' + ';\n    }\n\n    result += this._constant;\n\n    return result;\n  }\n\n  private _terms: IMap<Variable, number>;\n  private _constant: number;\n}\n\n/**\n * An internal interface for the argument parse results.\n */\ninterface IParseResult {\n  terms: IMap<Variable, number>;\n  constant: number;\n}\n\n/**\n * An internal argument parsing function.\n * @private\n */\nfunction parseArgs(args: IArguments): IParseResult {\n  let constant = 0.0;\n  let factory = () => 0.0;\n  let terms = createMap<Variable, number>();\n  for (let i = 0, n = args.length; i < n; ++i) {\n    let item = args[i];\n    if (typeof item === 'number') {\n      constant += item;\n    } else if (item instanceof Variable) {\n      terms.setDefault(item, factory).second += 1.0;\n    } else if (item instanceof Expression) {\n      constant += item.constant();\n      let terms2 = item.terms();\n      for (let j = 0, k = terms2.size(); j < k; j++) {\n        let termPair = terms2.itemAt(j);\n        terms.setDefault(termPair.first, factory).second += termPair.second;\n      }\n    } else if (item instanceof Array) {\n      if (item.length !== 2) {\n        throw new Error('array must have length 2');\n      }\n      let value: number = item[0];\n      let value2 = item[1];\n      if (typeof value !== 'number') {\n        throw new Error('array item 0 must be a number');\n      }\n      if (value2 instanceof Variable) {\n        terms.setDefault(value2, factory).second += value;\n      } else if (value2 instanceof Expression) {\n        constant += value2.constant() * value;\n        let terms2 = value2.terms();\n        for (let j = 0, k = terms2.size(); j < k; j++) {\n          let termPair = terms2.itemAt(j);\n          terms.setDefault(termPair.first, factory).second +=\n            termPair.second * value;\n        }\n      } else {\n        throw new Error('array item 1 must be a variable or expression');\n      }\n    } else {\n      throw new Error('invalid Expression argument: ' + item);\n    }\n  }\n  return { terms, constant };\n}\n","/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\n\n/**\n * @class Strength\n */\nexport class Strength {\n  /**\n   * Create a new symbolic strength.\n   *\n   * @param a strong\n   * @param b medium\n   * @param c weak\n   * @param [w] weight\n   * @return strength\n   */\n  static create(a: number, b: number, c: number, w: number = 1.0) {\n    let result: number = 0.0;\n    result += Math.max(0.0, Math.min(1000.0, a * w)) * 1000000.0;\n    result += Math.max(0.0, Math.min(1000.0, b * w)) * 1000.0;\n    result += Math.max(0.0, Math.min(1000.0, c * w));\n    return result;\n  }\n\n  /**\n   * The 'required' symbolic strength.\n   */\n  static required = Strength.create(1000.0, 1000.0, 1000.0);\n\n  /**\n   * The 'strong' symbolic strength.\n   */\n  static strong = Strength.create(1.0, 0.0, 0.0);\n\n  /**\n   * The 'medium' symbolic strength.\n   */\n  static medium = Strength.create(0.0, 1.0, 0.0);\n\n  /**\n   * The 'weak' symbolic strength.\n   */\n  static weak = Strength.create(0.0, 0.0, 1.0);\n\n  /**\n   * Clip a symbolic strength to the allowed min and max.\n   * @private\n   */\n  static clip(value: number) {\n    return Math.max(0.0, Math.min(Strength.required, value));\n  }\n}\n","/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\n\nimport { Expression } from './expression';\nimport { Strength } from './strength';\nimport { Variable } from './variable';\n\n/**\n * An enum defining the linear constraint operators.\n *\n * |Value|Operator|Description|\n * |----|-----|-----|\n * |`Le`|<=|Less than equal|\n * |`Ge`|>=|Greater than equal|\n * |`Eq`|==|Equal|\n *\n * @enum {Number}\n */\nexport enum Operator {\n  Le, // <=\n  Ge, // >=\n  Eq, // ==\n}\n\n/**\n * A linear constraint equation.\n *\n * A constraint equation is composed of an expression, an operator,\n * and a strength. The RHS of the equation is implicitly zero.\n *\n * @class\n * @param {Expression} expression The constraint expression (LHS).\n * @param {Operator} operator The equation operator.\n * @param {Expression} [rhs] Right hand side of the expression.\n * @param {Number} [strength=Strength.required] The strength of the constraint.\n */\nexport class Constraint {\n  constructor(\n    expression: Expression | Variable,\n    operator: Operator,\n    rhs?: Expression | Variable | number,\n    strength: number = Strength.required\n  ) {\n    this._operator = operator;\n    this._strength = Strength.clip(strength);\n    if (rhs === undefined && expression instanceof Expression) {\n      this._expression = expression;\n    } else {\n      this._expression = expression.minus(rhs);\n    }\n  }\n\n  /**\n   * Returns the unique id number of the constraint.\n   * @private\n   */\n  public id(): number {\n    return this._id;\n  }\n\n  /**\n   * Returns the expression of the constraint.\n   *\n   * @return {Expression} expression\n   */\n  public expression(): Expression {\n    return this._expression;\n  }\n\n  /**\n   * Returns the relational operator of the constraint.\n   *\n   * @return {Operator} linear constraint operator\n   */\n  public op(): Operator {\n    return this._operator;\n  }\n\n  /**\n   * Returns the strength of the constraint.\n   *\n   * @return {Number} strength\n   */\n  public strength(): number {\n    return this._strength;\n  }\n\n  public toString(): string {\n    return (\n      this._expression.toString() +\n      ' ' +\n      ['<=', '>=', '='][this._operator] +\n      ' 0 (' +\n      this._strength.toString() +\n      ')'\n    );\n  }\n\n  private _expression: Expression;\n  private _operator: Operator;\n  private _strength: number;\n  private _id: number = CnId++;\n}\n\n/**\n * The internal constraint id counter.\n * @private\n */\nlet CnId = 0;\n","/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\n\nexport interface IMap<T extends { id(): number }, U> extends IndexedMap<T, U> {}\n\nexport function createMap<T extends { id(): number }, U>(): IMap<T, U> {\n  return new IndexedMap<T, U>();\n}\n\nclass IndexedMap<T extends { id(): number }, U> {\n  public index = {} as { [id: number]: number | undefined };\n  public array = [] as Array<Pair<T, U>>;\n\n  /**\n   * Returns the number of items in the array.\n   */\n  public size(): number {\n    return this.array.length;\n  }\n\n  /**\n   * Returns true if the array is empty.\n   */\n  public empty(): boolean {\n    return this.array.length === 0;\n  }\n\n  /**\n   * Returns the item at the given array index.\n   *\n   * @param index The integer index of the desired item.\n   */\n  public itemAt(index: number): Pair<T, U> {\n    return this.array[index];\n  }\n\n  /**\n   * Returns true if the key is in the array, false otherwise.\n   *\n   * @param key The key to locate in the array.\n   */\n  public contains(key: T) {\n    return this.index[key.id()] !== undefined;\n  }\n\n  /**\n   * Returns the pair associated with the given key, or undefined.\n   *\n   * @param key The key to locate in the array.\n   */\n  public find(key: T) {\n    const i = this.index[key.id()];\n    return i === undefined ? undefined : this.array[i];\n  }\n\n  /**\n   * Returns the pair associated with the key if it exists.\n   *\n   * If the key does not exist, a new pair will be created and\n   * inserted using the value created by the given factory.\n   *\n   * @param key The key to locate in the array.\n   * @param factory The function which creates the default value.\n   */\n  public setDefault(key: T, factory: () => U): Pair<T, U> {\n    const i = this.index[key.id()];\n    if (i === undefined) {\n      const pair = new Pair(key, factory());\n      this.index[key.id()] = this.array.length;\n      this.array.push(pair);\n      return pair;\n    } else {\n      return this.array[i];\n    }\n  }\n\n  /**\n   * Insert the pair into the array and return the pair.\n   *\n   * This will overwrite any existing entry in the array.\n   *\n   * @param key The key portion of the pair.\n   * @param value The value portion of the pair.\n   */\n  public insert(key: T, value: U): Pair<T, U> {\n    const pair = new Pair(key, value);\n    const i = this.index[key.id()];\n    if (i === undefined) {\n      this.index[key.id()] = this.array.length;\n      this.array.push(pair);\n    } else {\n      this.array[i] = pair;\n    }\n    return pair;\n  }\n\n  /**\n   * Removes and returns the pair for the given key, or undefined.\n   *\n   * @param key The key to remove from the map.\n   */\n  public erase(key: T): Pair<T, U> {\n    const i = this.index[key.id()];\n    if (i === undefined) {\n      return undefined;\n    }\n    this.index[key.id()] = undefined;\n    const pair = this.array[i];\n    const last = this.array.pop();\n    if (pair !== last) {\n      this.array[i] = last;\n      this.index[last.first.id()] = i;\n    }\n    return pair;\n  }\n\n  /**\n   * Create a copy of this associative array.\n   */\n  public copy(): IndexedMap<T, U> {\n    const copy = new IndexedMap<T, U>();\n    for (let i = 0; i < this.array.length; i++) {\n      const pair = this.array[i].copy();\n      copy.array[i] = pair;\n      copy.index[pair.first.id()] = i;\n    }\n    return copy;\n  }\n}\n\n/**\n * A class which defines a generic pair object.\n * @private\n */\n// tslint:disable: max-classes-per-file\nclass Pair<T, U> {\n  /**\n   * Construct a new Pair object.\n   *\n   * @param first The first item of the pair.\n   * @param second The second item of the pair.\n   */\n  constructor(public first: T, public second: U) {}\n\n  /**\n   * Create a copy of the pair.\n   */\n  public copy() {\n    return new Pair(this.first, this.second);\n  }\n}\n","/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\n\nimport { Expression } from './expression';\n\n/**\n * The primary user constraint variable.\n *\n * @class\n * @param {String} [name=\"\"] The name to associated with the variable.\n */\nexport class Variable {\n  constructor(name: string = '') {\n    this._name = name;\n  }\n\n  /**\n   * Returns the unique id number of the variable.\n   * @private\n   */\n  public id(): number {\n    return this._id;\n  }\n\n  /**\n   * Returns the name of the variable.\n   *\n   * @return {String} name of the variable\n   */\n  public name(): string {\n    return this._name;\n  }\n\n  /**\n   * Set the name of the variable.\n   *\n   * @param {String} name Name of the variable\n   */\n  public setName(name: string): void {\n    this._name = name;\n  }\n\n  /**\n   * Returns the user context object of the variable.\n   * @private\n   */\n  public context(): any {\n    return this._context;\n  }\n\n  /**\n   * Set the user context object of the variable.\n   * @private\n   */\n  public setContext(context: any): void {\n    this._context = context;\n  }\n\n  /**\n   * Returns the value of the variable.\n   *\n   * @return {Number} Calculated value\n   */\n  public value(): number {\n    return this._value;\n  }\n\n  /**\n   * Set the value of the variable.\n   * @private\n   */\n  public setValue(value: number): void {\n    this._value = value;\n  }\n\n  /**\n   * Creates a new Expression by adding a number, variable or expression\n   * to the variable.\n   *\n   * @param {Number|Variable|Expression} value Value to add.\n   * @return {Expression} expression\n   */\n  public plus(value: number | Variable | Expression): Expression {\n    return new Expression(this, value);\n  }\n\n  /**\n   * Creates a new Expression by substracting a number, variable or expression\n   * from the variable.\n   *\n   * @param {Number|Variable|Expression} value Value to substract.\n   * @return {Expression} expression\n   */\n  public minus(value: number | Variable | Expression): Expression {\n    return new Expression(\n      this,\n      typeof value === 'number' ? -value : [-1, value]\n    );\n  }\n\n  /**\n   * Creates a new Expression by multiplying with a fixed number.\n   *\n   * @param {Number} coefficient Coefficient to multiply with.\n   * @return {Expression} expression\n   */\n  public multiply(coefficient: number): Expression {\n    return new Expression([coefficient, this]);\n  }\n\n  /**\n   * Creates a new Expression by dividing with a fixed number.\n   *\n   * @param {Number} coefficient Coefficient to divide by.\n   * @return {Expression} expression\n   */\n  public divide(coefficient: number): Expression {\n    return new Expression([1 / coefficient, this]);\n  }\n\n  /**\n   * Returns the JSON representation of the variable.\n   * @private\n   */\n  public toJSON(): any {\n    return {\n      name: this._name,\n      value: this._value,\n    };\n  }\n\n  public toString(): string {\n    return this._context + '[' + this._name + ':' + this._value + ']';\n  }\n\n  private _name: string;\n  private _value: number = 0.0;\n  private _context: any = null;\n  private _id: number = VarId++;\n}\n\n/**\n * The internal variable id counter.\n * @private\n */\nlet VarId = 0;\n","/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2018, Nucleic Development Team & H. Rutjes.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\n\nexport * from './constraint';\nexport * from './expression';\nexport * from './solver';\nexport * from './strength';\nexport * from './variable';\n","/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\n\nimport { Constraint, Operator } from './constraint';\nimport { Expression } from './expression';\nimport { createMap, IMap } from './maptype';\nimport { Strength } from './strength';\nimport { Variable } from './variable';\n\n/**\n * The constraint solver class.\n *\n * @class\n */\nexport class Solver {\n  /**\n   * Construct a new Solver.\n   */\n  constructor() {}\n\n  /**\n   * Creates and add a constraint to the solver.\n   *\n   * @param {Expression|Variable} lhs Left hand side of the expression\n   * @param {Operator} operator Operator\n   * @param {Expression|Variable|Number} rhs Right hand side of the expression\n   * @param {Number} [strength=Strength.required] Strength\n   */\n  public createConstraint(\n    lhs: Expression | Variable,\n    operator: Operator,\n    rhs: Expression | Variable | number,\n    strength: number = Strength.required\n  ): Constraint {\n    let cn = new Constraint(lhs, operator, rhs, strength);\n    this.addConstraint(cn);\n    return cn;\n  }\n\n  /**\n   * Add a constraint to the solver.\n   *\n   * @param {Constraint} constraint Constraint to add to the solver\n   */\n  public addConstraint(constraint: Constraint): void {\n    let cnPair = this._cnMap.find(constraint);\n    if (cnPair !== undefined) {\n      throw new Error('duplicate constraint');\n    }\n\n    // Creating a row causes symbols to be reserved for the variables\n    // in the constraint. If this method exits with an exception,\n    // then its possible those variables will linger in the var map.\n    // Since its likely that those variables will be used in other\n    // constraints and since exceptional conditions are uncommon,\n    // i'm not too worried about aggressive cleanup of the var map.\n    let data = this._createRow(constraint);\n    let row = data.row;\n    let tag = data.tag;\n    let subject = this._chooseSubject(row, tag);\n\n    // If chooseSubject couldnt find a valid entering symbol, one\n    // last option is available if the entire row is composed of\n    // dummy variables. If the constant of the row is zero, then\n    // this represents redundant constraints and the new dummy\n    // marker can enter the basis. If the constant is non-zero,\n    // then it represents an unsatisfiable constraint.\n    if (subject.type() === SymbolType.Invalid && row.allDummies()) {\n      if (!nearZero(row.constant())) {\n        throw new Error('unsatisfiable constraint');\n      } else {\n        subject = tag.marker;\n      }\n    }\n\n    // If an entering symbol still isn't found, then the row must\n    // be added using an artificial variable. If that fails, then\n    // the row represents an unsatisfiable constraint.\n    if (subject.type() === SymbolType.Invalid) {\n      if (!this._addWithArtificialVariable(row)) {\n        throw new Error('unsatisfiable constraint');\n      }\n    } else {\n      row.solveFor(subject);\n      this._substitute(subject, row);\n      this._rowMap.insert(subject, row);\n    }\n\n    this._cnMap.insert(constraint, tag);\n\n    // Optimizing after each constraint is added performs less\n    // aggregate work due to a smaller average system size. It\n    // also ensures the solver remains in a consistent state.\n    this._optimize(this._objective);\n  }\n\n  /**\n   * Remove a constraint from the solver.\n   *\n   * @param {Constraint} constraint Constraint to remove from the solver\n   */\n  public removeConstraint(constraint: Constraint): void {\n    let cnPair = this._cnMap.erase(constraint);\n    if (cnPair === undefined) {\n      throw new Error('unknown constraint');\n    }\n\n    // Remove the error effects from the objective function\n    // *before* pivoting, or substitutions into the objective\n    // will lead to incorrect solver results.\n    this._removeConstraintEffects(constraint, cnPair.second);\n\n    // If the marker is basic, simply drop the row. Otherwise,\n    // pivot the marker into the basis and then drop the row.\n    let marker = cnPair.second.marker;\n    let rowPair = this._rowMap.erase(marker);\n    if (rowPair === undefined) {\n      let leaving = this._getMarkerLeavingSymbol(marker);\n      if (leaving.type() === SymbolType.Invalid) {\n        throw new Error('failed to find leaving row');\n      }\n      rowPair = this._rowMap.erase(leaving);\n      rowPair.second.solveForEx(leaving, marker);\n      this._substitute(marker, rowPair.second);\n    }\n\n    // Optimizing after each constraint is removed ensures that the\n    // solver remains consistent. It makes the solver api easier to\n    // use at a small tradeoff for speed.\n    this._optimize(this._objective);\n  }\n\n  /**\n   * Test whether the solver contains the constraint.\n   *\n   * @param {Constraint} constraint Constraint to test for\n   * @return {Bool} true or false\n   */\n  public hasConstraint(constraint: Constraint): boolean {\n    return this._cnMap.contains(constraint);\n  }\n\n  /**\n   * Add an edit variable to the solver.\n   *\n   * @param {Variable} variable Edit variable to add to the solver\n   * @param {Number} strength Strength, should be less than `Strength.required`\n   */\n  public addEditVariable(variable: Variable, strength: number): void {\n    let editPair = this._editMap.find(variable);\n    if (editPair !== undefined) {\n      throw new Error('duplicate edit variable');\n    }\n    strength = Strength.clip(strength);\n    if (strength === Strength.required) {\n      throw new Error('bad required strength');\n    }\n    let expr = new Expression(variable);\n    let cn = new Constraint(expr, Operator.Eq, undefined, strength);\n    this.addConstraint(cn);\n    let tag = this._cnMap.find(cn).second;\n    let info = { tag, constraint: cn, constant: 0.0 };\n    this._editMap.insert(variable, info);\n  }\n\n  /**\n   * Remove an edit variable from the solver.\n   *\n   * @param {Variable} variable Edit variable to remove from the solver\n   */\n  public removeEditVariable(variable: Variable): void {\n    let editPair = this._editMap.erase(variable);\n    if (editPair === undefined) {\n      throw new Error('unknown edit variable');\n    }\n    this.removeConstraint(editPair.second.constraint);\n  }\n\n  /**\n   * Test whether the solver contains the edit variable.\n   *\n   * @param {Variable} variable Edit variable to test for\n   * @return {Bool} true or false\n   */\n  public hasEditVariable(variable: Variable): boolean {\n    return this._editMap.contains(variable);\n  }\n\n  /**\n   * Suggest the value of an edit variable.\n   *\n   * @param {Variable} variable Edit variable to suggest a value for\n   * @param {Number} value Suggested value\n   */\n  public suggestValue(variable: Variable, value: number): void {\n    let editPair = this._editMap.find(variable);\n    if (editPair === undefined) {\n      throw new Error('unknown edit variable');\n    }\n\n    let rows = this._rowMap;\n    let info = editPair.second;\n    let delta = value - info.constant;\n    info.constant = value;\n\n    // Check first if the positive error variable is basic.\n    let marker = info.tag.marker;\n    let rowPair = rows.find(marker);\n    if (rowPair !== undefined) {\n      if (rowPair.second.add(-delta) < 0.0) {\n        this._infeasibleRows.push(marker);\n      }\n      this._dualOptimize();\n      return;\n    }\n\n    // Check next if the negative error variable is basic.\n    let other = info.tag.other;\n    rowPair = rows.find(other);\n    if (rowPair !== undefined) {\n      if (rowPair.second.add(delta) < 0.0) {\n        this._infeasibleRows.push(other);\n      }\n      this._dualOptimize();\n      return;\n    }\n\n    // Otherwise update each row where the error variables exist.\n    for (let i = 0, n = rows.size(); i < n; ++i) {\n      let rowPair = rows.itemAt(i);\n      let row = rowPair.second;\n      let coeff = row.coefficientFor(marker);\n      if (\n        coeff !== 0.0 &&\n        row.add(delta * coeff) < 0.0 &&\n        rowPair.first.type() !== SymbolType.External\n      ) {\n        this._infeasibleRows.push(rowPair.first);\n      }\n    }\n    this._dualOptimize();\n  }\n\n  /**\n   * Update the values of the variables.\n   */\n  public updateVariables(): void {\n    let vars = this._varMap;\n    let rows = this._rowMap;\n    for (let i = 0, n = vars.size(); i < n; ++i) {\n      let pair = vars.itemAt(i);\n      let rowPair = rows.find(pair.second);\n      if (rowPair !== undefined) {\n        pair.first.setValue(rowPair.second.constant());\n      } else {\n        pair.first.setValue(0.0);\n      }\n    }\n  }\n\n  /**\n   * Get the symbol for the given variable.\n   *\n   * If a symbol does not exist for the variable, one will be created.\n   * @private\n   */\n  private _getVarSymbol(variable: Variable): Symbol {\n    let factory = () => this._makeSymbol(SymbolType.External);\n    return this._varMap.setDefault(variable, factory).second;\n  }\n\n  /**\n   * Create a new Row object for the given constraint.\n   *\n   * The terms in the constraint will be converted to cells in the row.\n   * Any term in the constraint with a coefficient of zero is ignored.\n   * This method uses the `_getVarSymbol` method to get the symbol for\n   * the variables added to the row. If the symbol for a given cell\n   * variable is basic, the cell variable will be substituted with the\n   * basic row.\n   *\n   * The necessary slack and error variables will be added to the row.\n   * If the constant for the row is negative, the sign for the row\n   * will be inverted so the constant becomes positive.\n   *\n   * Returns the created Row and the tag for tracking the constraint.\n   * @private\n   */\n  private _createRow(constraint: Constraint): IRowCreation {\n    let expr = constraint.expression();\n    let row = new Row(expr.constant());\n\n    // Substitute the current basic variables into the row.\n    let terms = expr.terms();\n    for (let i = 0, n = terms.size(); i < n; ++i) {\n      let termPair = terms.itemAt(i);\n      if (!nearZero(termPair.second)) {\n        let symbol = this._getVarSymbol(termPair.first);\n        let basicPair = this._rowMap.find(symbol);\n        if (basicPair !== undefined) {\n          row.insertRow(basicPair.second, termPair.second);\n        } else {\n          row.insertSymbol(symbol, termPair.second);\n        }\n      }\n    }\n\n    // Add the necessary slack, error, and dummy variables.\n    let objective = this._objective;\n    let strength = constraint.strength();\n    let tag = { marker: INVALID_SYMBOL, other: INVALID_SYMBOL };\n    switch (constraint.op()) {\n      case Operator.Le:\n      case Operator.Ge: {\n        let coeff = constraint.op() === Operator.Le ? 1.0 : -1.0;\n        let slack = this._makeSymbol(SymbolType.Slack);\n        tag.marker = slack;\n        row.insertSymbol(slack, coeff);\n        if (strength < Strength.required) {\n          let error = this._makeSymbol(SymbolType.Error);\n          tag.other = error;\n          row.insertSymbol(error, -coeff);\n          objective.insertSymbol(error, strength);\n        }\n        break;\n      }\n      case Operator.Eq: {\n        if (strength < Strength.required) {\n          let errplus = this._makeSymbol(SymbolType.Error);\n          let errminus = this._makeSymbol(SymbolType.Error);\n          tag.marker = errplus;\n          tag.other = errminus;\n          row.insertSymbol(errplus, -1.0); // v = eplus - eminus\n          row.insertSymbol(errminus, 1.0); // v - eplus + eminus = 0\n          objective.insertSymbol(errplus, strength);\n          objective.insertSymbol(errminus, strength);\n        } else {\n          let dummy = this._makeSymbol(SymbolType.Dummy);\n          tag.marker = dummy;\n          row.insertSymbol(dummy);\n        }\n        break;\n      }\n    }\n\n    // Ensure the row has a positive constant.\n    if (row.constant() < 0.0) {\n      row.reverseSign();\n    }\n\n    return { row, tag };\n  }\n\n  /**\n   * Choose the subject for solving for the row.\n   *\n   * This method will choose the best subject for using as the solve\n   * target for the row. An invalid symbol will be returned if there\n   * is no valid target.\n   *\n   * The symbols are chosen according to the following precedence:\n   *\n   * 1) The first symbol representing an external variable.\n   * 2) A negative slack or error tag variable.\n   *\n   * If a subject cannot be found, an invalid symbol will be returned.\n   *\n   * @private\n   */\n  private _chooseSubject(row: Row, tag: ITag): Symbol {\n    let cells = row.cells();\n    for (let i = 0, n = cells.size(); i < n; ++i) {\n      let pair = cells.itemAt(i);\n      if (pair.first.type() === SymbolType.External) {\n        return pair.first;\n      }\n    }\n    let type = tag.marker.type();\n    if (type === SymbolType.Slack || type === SymbolType.Error) {\n      if (row.coefficientFor(tag.marker) < 0.0) {\n        return tag.marker;\n      }\n    }\n    type = tag.other.type();\n    if (type === SymbolType.Slack || type === SymbolType.Error) {\n      if (row.coefficientFor(tag.other) < 0.0) {\n        return tag.other;\n      }\n    }\n    return INVALID_SYMBOL;\n  }\n\n  /**\n   * Add the row to the tableau using an artificial variable.\n   *\n   * This will return false if the constraint cannot be satisfied.\n   *\n   * @private\n   */\n  private _addWithArtificialVariable(row: Row): boolean {\n    // Create and add the artificial variable to the tableau.\n    let art = this._makeSymbol(SymbolType.Slack);\n    this._rowMap.insert(art, row.copy());\n    this._artificial = row.copy();\n\n    // Optimize the artificial objective. This is successful\n    // only if the artificial objective is optimized to zero.\n    this._optimize(this._artificial);\n    let success = nearZero(this._artificial.constant());\n    this._artificial = null;\n\n    // If the artificial variable is basic, pivot the row so that\n    // it becomes non-basic. If the row is constant, exit early.\n    let pair = this._rowMap.erase(art);\n    if (pair !== undefined) {\n      let basicRow = pair.second;\n      if (basicRow.isConstant()) {\n        return success;\n      }\n      let entering = this._anyPivotableSymbol(basicRow);\n      if (entering.type() === SymbolType.Invalid) {\n        return false; // unsatisfiable (will this ever happen?)\n      }\n      basicRow.solveForEx(art, entering);\n      this._substitute(entering, basicRow);\n      this._rowMap.insert(entering, basicRow);\n    }\n\n    // Remove the artificial variable from the tableau.\n    let rows = this._rowMap;\n    for (let i = 0, n = rows.size(); i < n; ++i) {\n      rows.itemAt(i).second.removeSymbol(art);\n    }\n    this._objective.removeSymbol(art);\n    return success;\n  }\n\n  /**\n   * Substitute the parametric symbol with the given row.\n   *\n   * This method will substitute all instances of the parametric symbol\n   * in the tableau and the objective function with the given row.\n   *\n   * @private\n   */\n  private _substitute(symbol: Symbol, row: Row): void {\n    let rows = this._rowMap;\n    for (let i = 0, n = rows.size(); i < n; ++i) {\n      let pair = rows.itemAt(i);\n      pair.second.substitute(symbol, row);\n      if (\n        pair.second.constant() < 0.0 &&\n        pair.first.type() !== SymbolType.External\n      ) {\n        this._infeasibleRows.push(pair.first);\n      }\n    }\n    this._objective.substitute(symbol, row);\n    if (this._artificial) {\n      this._artificial.substitute(symbol, row);\n    }\n  }\n\n  /**\n   * Optimize the system for the given objective function.\n   *\n   * This method performs iterations of Phase 2 of the simplex method\n   * until the objective function reaches a minimum.\n   *\n   * @private\n   */\n  private _optimize(objective: Row): void {\n    while (true) {\n      let entering = this._getEnteringSymbol(objective);\n      if (entering.type() === SymbolType.Invalid) {\n        return;\n      }\n      let leaving = this._getLeavingSymbol(entering);\n      if (leaving.type() === SymbolType.Invalid) {\n        throw new Error('the objective is unbounded');\n      }\n      // pivot the entering symbol into the basis\n      let row = this._rowMap.erase(leaving).second;\n      row.solveForEx(leaving, entering);\n      this._substitute(entering, row);\n      this._rowMap.insert(entering, row);\n    }\n  }\n\n  /**\n   * Optimize the system using the dual of the simplex method.\n   *\n   * The current state of the system should be such that the objective\n   * function is optimal, but not feasible. This method will perform\n   * an iteration of the dual simplex method to make the solution both\n   * optimal and feasible.\n   *\n   * @private\n   */\n  private _dualOptimize(): void {\n    let rows = this._rowMap;\n    let infeasible = this._infeasibleRows;\n    while (infeasible.length !== 0) {\n      let leaving = infeasible.pop();\n      let pair = rows.find(leaving);\n      if (pair !== undefined && pair.second.constant() < 0.0) {\n        let entering = this._getDualEnteringSymbol(pair.second);\n        if (entering.type() === SymbolType.Invalid) {\n          throw new Error('dual optimize failed');\n        }\n        // pivot the entering symbol into the basis\n        let row = pair.second;\n        rows.erase(leaving);\n        row.solveForEx(leaving, entering);\n        this._substitute(entering, row);\n        rows.insert(entering, row);\n      }\n    }\n  }\n\n  /**\n   * Compute the entering variable for a pivot operation.\n   *\n   * This method will return first symbol in the objective function which\n   * is non-dummy and has a coefficient less than zero. If no symbol meets\n   * the criteria, it means the objective function is at a minimum, and an\n   * invalid symbol is returned.\n   *\n   * @private\n   */\n  private _getEnteringSymbol(objective: Row): Symbol {\n    let cells = objective.cells();\n    for (let i = 0, n = cells.size(); i < n; ++i) {\n      let pair = cells.itemAt(i);\n      let symbol = pair.first;\n      if (pair.second < 0.0 && symbol.type() !== SymbolType.Dummy) {\n        return symbol;\n      }\n    }\n    return INVALID_SYMBOL;\n  }\n\n  /**\n   * Compute the entering symbol for the dual optimize operation.\n   *\n   * This method will return the symbol in the row which has a positive\n   * coefficient and yields the minimum ratio for its respective symbol\n   * in the objective function. The provided row *must* be infeasible.\n   * If no symbol is found which meats the criteria, an invalid symbol\n   * is returned.\n   *\n   * @private\n   */\n  private _getDualEnteringSymbol(row: Row): Symbol {\n    let ratio = Number.MAX_VALUE;\n    let entering = INVALID_SYMBOL;\n    let cells = row.cells();\n    for (let i = 0, n = cells.size(); i < n; ++i) {\n      let pair = cells.itemAt(i);\n      let symbol = pair.first;\n      let c = pair.second;\n      if (c > 0.0 && symbol.type() !== SymbolType.Dummy) {\n        let coeff = this._objective.coefficientFor(symbol);\n        let r = coeff / c;\n        if (r < ratio) {\n          ratio = r;\n          entering = symbol;\n        }\n      }\n    }\n    return entering;\n  }\n\n  /**\n   * Compute the symbol for pivot exit row.\n   *\n   * This method will return the symbol for the exit row in the row\n   * map. If no appropriate exit symbol is found, an invalid symbol\n   * will be returned. This indicates that the objective function is\n   * unbounded.\n   *\n   * @private\n   */\n  private _getLeavingSymbol(entering: Symbol): Symbol {\n    let ratio = Number.MAX_VALUE;\n    let found = INVALID_SYMBOL;\n    let rows = this._rowMap;\n    for (let i = 0, n = rows.size(); i < n; ++i) {\n      let pair = rows.itemAt(i);\n      let symbol = pair.first;\n      if (symbol.type() !== SymbolType.External) {\n        let row = pair.second;\n        let temp = row.coefficientFor(entering);\n        if (temp < 0.0) {\n          let temp_ratio = -row.constant() / temp;\n          if (temp_ratio < ratio) {\n            ratio = temp_ratio;\n            found = symbol;\n          }\n        }\n      }\n    }\n    return found;\n  }\n\n  /**\n   * Compute the leaving symbol for a marker variable.\n   *\n   * This method will return a symbol corresponding to a basic row\n   * which holds the given marker variable. The row will be chosen\n   * according to the following precedence:\n   *\n   * 1) The row with a restricted basic varible and a negative coefficient\n   *    for the marker with the smallest ratio of -constant / coefficient.\n   *\n   * 2) The row with a restricted basic variable and the smallest ratio\n   *    of constant / coefficient.\n   *\n   * 3) The last unrestricted row which contains the marker.\n   *\n   * If the marker does not exist in any row, an invalid symbol will be\n   * returned. This indicates an internal solver error since the marker\n   * *should* exist somewhere in the tableau.\n   *\n   * @private\n   */\n  private _getMarkerLeavingSymbol(marker: Symbol): Symbol {\n    let dmax = Number.MAX_VALUE;\n    let r1 = dmax;\n    let r2 = dmax;\n    let invalid = INVALID_SYMBOL;\n    let first = invalid;\n    let second = invalid;\n    let third = invalid;\n    let rows = this._rowMap;\n    for (let i = 0, n = rows.size(); i < n; ++i) {\n      let pair = rows.itemAt(i);\n      let row = pair.second;\n      let c = row.coefficientFor(marker);\n      if (c === 0.0) {\n        continue;\n      }\n      let symbol = pair.first;\n      if (symbol.type() === SymbolType.External) {\n        third = symbol;\n      } else if (c < 0.0) {\n        let r = -row.constant() / c;\n        if (r < r1) {\n          r1 = r;\n          first = symbol;\n        }\n      } else {\n        let r = row.constant() / c;\n        if (r < r2) {\n          r2 = r;\n          second = symbol;\n        }\n      }\n    }\n    if (first !== invalid) {\n      return first;\n    }\n    if (second !== invalid) {\n      return second;\n    }\n    return third;\n  }\n\n  /**\n   * Remove the effects of a constraint on the objective function.\n   *\n   * @private\n   */\n  private _removeConstraintEffects(cn: Constraint, tag: ITag): void {\n    if (tag.marker.type() === SymbolType.Error) {\n      this._removeMarkerEffects(tag.marker, cn.strength());\n    }\n    if (tag.other.type() === SymbolType.Error) {\n      this._removeMarkerEffects(tag.other, cn.strength());\n    }\n  }\n\n  /**\n   * Remove the effects of an error marker on the objective function.\n   *\n   * @private\n   */\n  private _removeMarkerEffects(marker: Symbol, strength: number): void {\n    let pair = this._rowMap.find(marker);\n    if (pair !== undefined) {\n      this._objective.insertRow(pair.second, -strength);\n    } else {\n      this._objective.insertSymbol(marker, -strength);\n    }\n  }\n\n  /**\n   * Get the first Slack or Error symbol in the row.\n   *\n   * If no such symbol is present, an invalid symbol will be returned.\n   *\n   * @private\n   */\n  private _anyPivotableSymbol(row: Row): Symbol {\n    let cells = row.cells();\n    for (let i = 0, n = cells.size(); i < n; ++i) {\n      let pair = cells.itemAt(i);\n      let type = pair.first.type();\n      if (type === SymbolType.Slack || type === SymbolType.Error) {\n        return pair.first;\n      }\n    }\n    return INVALID_SYMBOL;\n  }\n\n  /**\n   * Returns a new Symbol of the given type.\n   *\n   * @private\n   */\n  private _makeSymbol(type: SymbolType): Symbol {\n    return new Symbol(type, this._idTick++);\n  }\n\n  private _cnMap = createCnMap();\n  private _rowMap = createRowMap();\n  private _varMap = createVarMap();\n  private _editMap = createEditMap();\n  private _infeasibleRows: Symbol[] = [];\n  private _objective: Row = new Row();\n  private _artificial: Row = null;\n  private _idTick: number = 0;\n}\n\n/**\n * Test whether a value is approximately zero.\n * @private\n */\nfunction nearZero(value: number): boolean {\n  let eps = 1.0e-8;\n  return value < 0.0 ? -value < eps : value < eps;\n}\n\n/**\n * The internal interface of a tag value.\n */\ninterface ITag {\n  marker: Symbol;\n  other: Symbol;\n}\n\n/**\n * The internal interface of an edit info object.\n */\ninterface IEditInfo {\n  tag: ITag;\n  constraint: Constraint;\n  constant: number;\n}\n\n/**\n * The internal interface for returning created row data.\n */\ninterface IRowCreation {\n  row: Row;\n  tag: ITag;\n}\n\n/**\n * An internal function for creating a constraint map.\n * @private\n */\nfunction createCnMap(): IMap<Constraint, ITag> {\n  return createMap<Constraint, ITag>();\n}\n\n/**\n * An internal function for creating a row map.\n * @private\n */\nfunction createRowMap(): IMap<Symbol, Row> {\n  return createMap<Symbol, Row>();\n}\n\n/**\n * An internal function for creating a variable map.\n * @private\n */\nfunction createVarMap(): IMap<Variable, Symbol> {\n  return createMap<Variable, Symbol>();\n}\n\n/**\n * An internal function for creating an edit map.\n * @private\n */\nfunction createEditMap(): IMap<Variable, IEditInfo> {\n  return createMap<Variable, IEditInfo>();\n}\n\n/**\n * An enum defining the available symbol types.\n * @private\n */\nenum SymbolType {\n  Invalid,\n  External,\n  Slack,\n  Error,\n  Dummy,\n}\n\n/**\n * An internal class representing a symbol in the solver.\n * @private\n */\nclass Symbol {\n  /**\n   * Construct a new Symbol\n   *\n   * @param [type] The type of the symbol.\n   * @param [id] The unique id number of the symbol.\n   */\n  constructor(type: SymbolType, id: number) {\n    this._id = id;\n    this._type = type;\n  }\n\n  /**\n   * Returns the unique id number of the symbol.\n   */\n  public id(): number {\n    return this._id;\n  }\n\n  /**\n   * Returns the type of the symbol.\n   */\n  public type(): SymbolType {\n    return this._type;\n  }\n\n  private _id: number;\n  private _type: SymbolType;\n}\n\n/**\n * A static invalid symbol\n * @private\n */\nlet INVALID_SYMBOL = new Symbol(SymbolType.Invalid, -1);\n\n/**\n * An internal row class used by the solver.\n * @private\n */\nclass Row {\n  /**\n   * Construct a new Row.\n   */\n  constructor(constant: number = 0.0) {\n    this._constant = constant;\n  }\n\n  /**\n   * Returns the mapping of symbols to coefficients.\n   */\n  public cells(): IMap<Symbol, number> {\n    return this._cellMap;\n  }\n\n  /**\n   * Returns the constant for the row.\n   */\n  public constant(): number {\n    return this._constant;\n  }\n\n  /**\n   * Returns true if the row is a constant value.\n   */\n  public isConstant(): boolean {\n    return this._cellMap.empty();\n  }\n\n  /**\n   * Returns true if the Row has all dummy symbols.\n   */\n  public allDummies(): boolean {\n    let cells = this._cellMap;\n    for (let i = 0, n = cells.size(); i < n; ++i) {\n      let pair = cells.itemAt(i);\n      if (pair.first.type() !== SymbolType.Dummy) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Create a copy of the row.\n   */\n  public copy(): Row {\n    let theCopy = new Row(this._constant);\n    theCopy._cellMap = this._cellMap.copy();\n    return theCopy;\n  }\n\n  /**\n   * Add a constant value to the row constant.\n   *\n   * Returns the new value of the constant.\n   */\n  public add(value: number): number {\n    return (this._constant += value);\n  }\n\n  /**\n   * Insert the symbol into the row with the given coefficient.\n   *\n   * If the symbol already exists in the row, the coefficient\n   * will be added to the existing coefficient. If the resulting\n   * coefficient is zero, the symbol will be removed from the row.\n   */\n  public insertSymbol(symbol: Symbol, coefficient: number = 1.0): void {\n    let pair = this._cellMap.setDefault(symbol, () => 0.0);\n    if (nearZero((pair.second += coefficient))) {\n      this._cellMap.erase(symbol);\n    }\n  }\n\n  /**\n   * Insert a row into this row with a given coefficient.\n   *\n   * The constant and the cells of the other row will be\n   * multiplied by the coefficient and added to this row. Any\n   * cell with a resulting coefficient of zero will be removed\n   * from the row.\n   */\n  public insertRow(other: Row, coefficient: number = 1.0): void {\n    this._constant += other._constant * coefficient;\n    let cells = other._cellMap;\n    for (let i = 0, n = cells.size(); i < n; ++i) {\n      let pair = cells.itemAt(i);\n      this.insertSymbol(pair.first, pair.second * coefficient);\n    }\n  }\n\n  /**\n   * Remove a symbol from the row.\n   */\n  public removeSymbol(symbol: Symbol): void {\n    this._cellMap.erase(symbol);\n  }\n\n  /**\n   * Reverse the sign of the constant and cells in the row.\n   */\n  public reverseSign(): void {\n    this._constant = -this._constant;\n    let cells = this._cellMap;\n    for (let i = 0, n = cells.size(); i < n; ++i) {\n      let pair = cells.itemAt(i);\n      pair.second = -pair.second;\n    }\n  }\n\n  /**\n   * Solve the row for the given symbol.\n   *\n   * This method assumes the row is of the form\n   * a * x + b * y + c = 0 and (assuming solve for x) will modify\n   * the row to represent the right hand side of\n   * x = -b/a * y - c / a. The target symbol will be removed from\n   * the row, and the constant and other cells will be multiplied\n   * by the negative inverse of the target coefficient.\n   *\n   * The given symbol *must* exist in the row.\n   */\n  public solveFor(symbol: Symbol): void {\n    let cells = this._cellMap;\n    let pair = cells.erase(symbol);\n    let coeff = -1.0 / pair.second;\n    this._constant *= coeff;\n    for (let i = 0, n = cells.size(); i < n; ++i) {\n      cells.itemAt(i).second *= coeff;\n    }\n  }\n\n  /**\n   * Solve the row for the given symbols.\n   *\n   * This method assumes the row is of the form\n   * x = b * y + c and will solve the row such that\n   * y = x / b - c / b. The rhs symbol will be removed from the\n   * row, the lhs added, and the result divided by the negative\n   * inverse of the rhs coefficient.\n   *\n   * The lhs symbol *must not* exist in the row, and the rhs\n   * symbol must* exist in the row.\n   */\n  public solveForEx(lhs: Symbol, rhs: Symbol): void {\n    this.insertSymbol(lhs, -1.0);\n    this.solveFor(rhs);\n  }\n\n  /**\n   * Returns the coefficient for the given symbol.\n   */\n  public coefficientFor(symbol: Symbol): number {\n    let pair = this._cellMap.find(symbol);\n    return pair !== undefined ? pair.second : 0.0;\n  }\n\n  /**\n   * Substitute a symbol with the data from another row.\n   *\n   * Given a row of the form a * x + b and a substitution of the\n   * form x = 3 * y + c the row will be updated to reflect the\n   * expression 3 * a * y + a * c + b.\n   *\n   * If the symbol does not exist in the row, this is a no-op.\n   */\n  public substitute(symbol: Symbol, row: Row): void {\n    let pair = this._cellMap.erase(symbol);\n    if (pair !== undefined) {\n      this.insertRow(row, pair.second);\n    }\n  }\n\n  private _cellMap = createMap<Symbol, number>();\n  private _constant: number;\n}\n"],"sourceRoot":""}